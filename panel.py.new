import eel
import json
import hashlib
import os
import threading
import time
import requests
import random
import string
import smtplib
import base64
from urllib.parse import urlparse
from email.mime.text import MIMEText
from email.header import Header
from datetime import datetime, timedelta
import spark_ai
import functools

# 配置文件路径
config_path = 'config.json'

# 读取配置文件
def read_config():
    if not os.path.exists(config_path):
        with open(config_path, 'w') as f:
            json.dump({'password_hash': ''}, f, indent=4)
        return {'password_hash': ''}
    
    with open(config_path, 'r', encoding='utf-8') as f:
        return json.load(f)

# 保存配置文件
def save_config(config):
    with open(config_path, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=4, ensure_ascii=False)

# 验证码存储字典和线程锁
verification_codes = {}
verification_lock = threading.Lock()

# 从配置文件中读取SMTP配置
def load_smtp_config():
    config = read_config()
    smtp_config = config.get('smtp_config', {})
    return {
        'smtp_server': smtp_config.get('smtp_server', 'smtp.qiye.163.com'),
        'smtp_port': smtp_config.get('smtp_port', 465),
        'sender': smtp_config.get('sender', 'qzgeek@zitat.cn'),
        'password': smtp_config.get('password', '')
    }

# SMTP连接全局变量
smtp_connection = None

smtp_config = load_smtp_config()

# 初始化SMTP连接函数
def init_smtp_connection():
    global smtp_connection
    try:
        smtp_server = smtp_config['smtp_server']
        smtp_port = smtp_config['smtp_port']
        sender = smtp_config['sender']
        password = smtp_config['password']
        
        smtp_connection = smtplib.SMTP_SSL(smtp_server, smtp_port)
        smtp_connection.set_debuglevel(1)  # 开启调试模式
        print(f"[INFO] 成功连接到SMTP服务器: {smtp_server}:{smtp_port}")

        smtp_connection.login(sender, password)
        print(f"[INFO] 成功登录邮箱: {sender}")
    except smtplib.SMTPAuthenticationError:
        print(f"[ERROR] 邮箱认证失败: 请检查用户名和密码/授权码是否正确")
    except smtplib.SMTPConnectError:
        print(f"[ERROR] 无法连接到SMTP服务器: {smtp_config['smtp_server']}:{smtp_config['smtp_port']}")
    except Exception as e:
        print(f"[ERROR] 初始化SMTP连接失败: {str(e)}")

# 关闭SMTP连接函数
def close_smtp_connection():
    global smtp_connection
    if smtp_connection:
        try:
            smtp_connection.quit()
            print(f"[INFO] SMTP连接已关闭")
        except Exception as e:
            print(f"[ERROR] 关闭SMTP连接时发生错误: {str(e)}")
smtp_connection = None
# 初始化EEL
eel.init('web',js_result_timeout=-1)

# 加密密码
# 定义盐值
SALT = "zitat1145"

def encrypt_password(password):
    # 使用盐值进行密码加密
    return hashlib.sha256((password + SALT).encode()).hexdigest()

# 用户数据管理
def load_users():
    """从users.json加载用户数据"""
    users_path = os.path.join('db', 'users.json')
    if not os.path.exists(users_path):
        return []
    try:
        with open(users_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError:
        print("[ERROR] 无法解析users.json，返回空用户列表")
        return []

def save_users(users):
    """保存用户数据到users.json"""
    # 使用绝对路径确保一致性
    users_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'db', 'users.json')
    try:
        # 确保db目录存在
        db_dir = os.path.dirname(users_path)
        os.makedirs(db_dir, exist_ok=True)
        
        # 检查目录权限
        if not os.access(db_dir, os.W_OK):
            print(f"[ERROR] 没有写入权限: {db_dir}")
            return False
        
        with open(users_path, 'w', encoding='utf-8') as f:
            json.dump(users, f, indent=4, ensure_ascii=False)
        print(f"[INFO] 成功保存用户数据到 {users_path}")
        print(f"[DEBUG] 保存的用户数量: {len(users)}")
        if len(users) > 0:
            print(f"[DEBUG] 最后一个用户: {users[-1]['email']}")
        return True
    except PermissionError:
        print(f"[ERROR] 权限错误: 无法写入文件 {users_path}")
        return False
    except Exception as e:
        print(f"[ERROR] 保存用户数据失败: {str(e)}")
        return False

def generate_verification_code():
    """生成6位数字验证码"""
    return ''.join(random.choices(string.digits, k=6))

# 暴露函数给前端
def cleanup_verification_code(email):
    """3分钟后清理验证码"""
    with verification_lock:
        if email in verification_codes:
            del verification_codes[email]
            print(f"[INFO] 验证码已过期，自动清理: {email}")

@eel.expose
def send_verification_code(email):
    """发送验证码到邮箱并存储到字典"""
    verification_code = generate_verification_code()
    expiration_time = datetime.now() + timedelta(minutes=3)
    
    with verification_lock:
        # 存储邮箱、验证码和过期时间
        verification_codes[email] = {
            'code': verification_code,
            'expires_at': expiration_time
        }
    print(f"[INFO] 收到前端请求，现在发送验证码。验证码: {verification_code}")
    # 启动3分钟后自动清理的线程
    threading.Timer(180, cleanup_verification_code, args=[email]).start()
    
    # 发送邮件
    # 创建邮件内容
    subject = '一谚控制台验证码'
    message = f'您的验证码是: {verification_code}，有效期3分钟。'
    
    msg = MIMEText(message, 'plain', 'utf-8')
    msg['From'] = Header(smtp_config['sender'])
    msg['To'] = Header(email)
    msg['Subject'] = Header(subject)
    
    # 使用全局SMTP连接发送邮件
    try:
        global smtp_connection
        # 检查连接是否存在且活跃
        if not smtp_connection:
            print(f"[WARN] SMTP连接不存在，尝试重新连接...")
            init_smtp_connection()
            if not smtp_connection:
                raise Exception("无法建立SMTP连接")

        smtp_connection.sendmail(smtp_config['sender'], [email], msg.as_string())
        print(f"[INFO] 验证码已发送到邮箱: {email}, 验证码: {verification_code}")
        return {'status': 'success', 'message': '验证码已发送到您的邮箱'}
    except smtplib.SMTPAuthenticationError:
        print(f"[ERROR] 邮箱认证失败: 请检查用户名和密码/授权码是否正确")
        # 尝试重新连接
        init_smtp_connection()
        return {'status': 'error', 'message': '邮箱认证失败: 请检查用户名和密码/授权码是否正确'}
    except smtplib.SMTPConnectError:
        print(f"[ERROR] 无法连接到SMTP服务器: {smtp_config['smtp_server']}:{smtp_config['smtp_port']}")
        # 尝试重新连接
        init_smtp_connection()
        return {'status': 'error', 'message': f'无法连接到SMTP服务器: {smtp_server}:{smtp_port}'}
    except Exception as e:
        print(f"[ERROR] 发送验证码失败: {str(e)}")
        # 尝试重新连接
        init_smtp_connection()
        return {'status': 'error', 'message': f'发送验证码失败: {str(e)}'}
@eel.expose
def register_user(email, password):
    """注册新用户"""
    if not password:
        return {'status': 'error', 'message': '密码不能为空'}
    
    print(f"[INFO] 开始注册用户: {email}")
    users = load_users()
    print(f"[DEBUG] 加载的用户数量: {len(users)}")
    
    # 检查邮箱是否已注册
    for user in users:
        if user['email'] == email:
            print(f"[WARN] 邮箱已被注册: {email}")
            return {'status': 'error', 'message': '邮箱已被注册'}
    
    # 加密密码
    hashed_password = encrypt_password(password)
    print(f"[DEBUG] 密码加密后: {hashed_password}")
    
    # 创建新用户
    new_user = {
        'email': email,
        'password': hashed_password,
        'verified': False,  # 初始设置为未验证
        'zitat': []  # 新增语录存储字段
    }
    
    users.append(new_user)
    print(f"[DEBUG] 添加新用户后数量: {len(users)}")
    print(f"[DEBUG] 新用户信息: {new_user}")
    save_success = save_users(users)
    if not save_success:
        print(f"[ERROR] 注册用户失败: 无法保存用户数据")
        return {'status': 'error', 'message': '注册失败，请稍后再试'}
    # 重新加载用户数据，验证是否保存成功
    reloaded_users = load_users()
    print(f"[DEBUG] 保存后重新加载的用户数量: {len(reloaded_users)}")
    user_found = False
    for user in reloaded_users:
        if user['email'] == email:
            user_found = True
            print(f"[DEBUG] 保存后的用户信息: {user}")
            break
    if user_found:
        print(f"[INFO] 用户数据保存成功: {email}")
    else:
        print(f"[ERROR] 用户数据保存失败: {email}")
    print(f"[INFO] 新用户注册: {email}")
    return {'status': 'success', 'message': '注册成功'}

@eel.expose
def verify_email(email, code):
    """验证邮箱验证码"""
    with verification_lock:
        # 检查邮箱是否存在于验证码字典中
        if email not in verification_codes:
            print(f"[WARN] 邮箱不存在或验证码已过期: {email}")
            return {'status': 'error', 'message': '邮箱不存在或验证码已过期'}
        
        # 检查验证码是否匹配
        stored_data = verification_codes[email]
        if stored_data['code'] != code:
            print(f"[WARN] 验证码不匹配: {email}")
            return {'status': 'error', 'message': '验证码不匹配'}
        
        # 检查是否过期
        if datetime.now() > stored_data['expires_at']:
            del verification_codes[email]
            print(f"[WARN] 验证码已过期: {email}")
            return {'status': 'error', 'message': '验证码已过期'}
        
        # 验证成功，删除验证码
        del verification_codes[email]
        print(f"[INFO] 验证码验证成功: {email}")
        
        # 更新用户状态
        users = load_users()
        user_found = False
        for user in users:
            if user['email'] == email:
                user['verified'] = True
                save_users(users)
                user_found = True
                break
        
        if not user_found:
            print(f"[WARN] 验证成功但未找到用户: {email}")
            return {'status': 'error', 'message': '验证成功但未找到用户'}
        
        return {'status': 'success', 'message': '验证码验证成功'}

@eel.expose
def login_user(email, password):
    """用户登录验证"""
    try:
        users = load_users()
        hashed_password = encrypt_password(password)
        
        print(f"[INFO] 登录尝试: {email}")
        print(f"[DEBUG] 加密后的密码: {hashed_password}")
        
        for user in users:
            if user['email'] == email:
                if user['password'] == hashed_password:
                    if user['verified']:
                        # 直接调用登录管理器设置状态，而不是通过eel
                        login_manager.set_login_status(True, email)
                        print(f"[INFO] 用户 {email} 登录成功")
                        return {'status': 'success', 'message': '登录成功!'}
                    else:
                        print(f"[WARN] 用户 {email} 邮箱未验证")
                        return {'status': 'error', 'message': '邮箱未验证!'}
                else:
                    print(f"[WARN] 用户 {email} 密码错误")
                    return {'status': 'error', 'message': '密码错误!'}
        
        print(f"[WARN] 用户 {email} 不存在")
        return {'status': 'error', 'message': '用户不存在!'}
    except Exception as e:
        print(f"[ERROR] 登录过程中发生错误: {str(e)}")
        return {'status': 'error', 'message': f'登录失败: {str(e)}'}

# 会话校验装饰器
def require_login(func):
    """装饰器：检查用户是否已登录"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if not login_manager.is_logged_in:
            return {'status': 'error', 'message': '请先登录'}
        return func(*args, **kwargs)
    return wrapper

# 登录状态管理
class LoginManager:
    _instance = None
    _is_logged_in = False
    _current_user_email = ''
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(LoginManager, cls).__new__(cls)
        return cls._instance
    
    @property
    def is_logged_in(self):
        with self._lock:
            return self._is_logged_in
    
    @property
    def current_user_email(self):
        with self._lock:
            return self._current_user_email
    
    def set_login_status(self, status, email=None):
        with self._lock:
            self._is_logged_in = status
            # 仅在登录成功时设置邮箱
            if status and email:
                self._current_user_email = email
            elif not status:
                self._current_user_email = ''
            print(f"[INFO] 登录状态已设置为: {status}")
            return {'status': 'success', 'message': '登录状态已更新'}

# 创建登录管理器实例
login_manager = LoginManager()

# 从配置文件中读取API配置
def load_api_config():
    config = read_config()
    api_config = config.get('api_config', {})
    return {
        'ai_http_url': api_config.get('ai_http_url', 'https://spark-api-open.xf-yun.com/v1/chat/completions'),
        'api_key': api_config.get('api_key', ''),
        'api_secret': api_config.get('api_secret', '')
    }

# 加载API配置
api_config = load_api_config()

# 生成HTTP认证头部
def generate_auth_headers():
    timestamp = str(int(time.time()))
    nonce = str(int(time.time() * 1000))
    
    # 从配置中获取API密钥
    api_key = api_config['api_key']
    
    # 生成签名
    signature_origin = f"api_key={api_key}&timestamp={timestamp}&nonce={nonce}"
    signature = hashlib.md5(signature_origin.encode('utf-8')).hexdigest()
    
    return {
        'Content-Type': 'application/json',
        'api_key': api_key,
        'timestamp': timestamp,
        'nonce': nonce,
        'signature': signature
    }

# AI审核句子内容
def ai_review_sentence(content, author, source):
    # 构建提示词
    prompt = f"你现在是一名谚语API的审核员，有人发来一条来自{author}的{source}中的句子，内容是{content}，请使用纯文本JSON的passed布尔值判定是否通过。"
    
    try:
        # 更新状态为审核中
        eel.status_update(3)
        eel.log_push('开始AI审核...')
        eel.sleep(0.1)  # 确保消息被发送
        
        # 调用spark_ai模块中的call_spark函数
        review_result = spark_ai.call_spark(prompt)
        # 过滤掉所有"`"符号和"json"字眼
        review_result = review_result.replace("`", "").replace("json", "")
        eel.log_push(f'AI返回过滤后结果: {review_result}')
        eel.sleep(0.1)  # 确保消息被发送
        
        # 解析JSON结果
        try:
            review_json = json.loads(review_result)
            eel.log_push('审核结果解析成功')
            eel.sleep(0.1)
            passed = review_json.get('passed', False)
            # 更新状态为成功或失败
            eel.status_update(1 if passed else 2)
            eel.sleep(0.1)
            return passed
        except json.JSONDecodeError:
            eel.log_push(f'JSON解析失败，原始响应: {review_result}')
            eel.sleep(0.1)
            eel.status_update(2)  # 解析失败也视为审核未通过
            eel.sleep(0.1)
            raise ValueError(f'AI返回结果不是有效的JSON: {review_result}')
    except Exception as e:
        print(f"[ERROR] AI审核请求失败: {str(e)}")
        raise

# 同步包装AI审核函数
def review_sentence_sync(content, author, source):
    try:
        return ai_review_sentence(content, author, source)
    except Exception as e:
        print(f"[ERROR] AI审核同步调用失败: {str(e)}")
        raise



# 设置登录状态函数
@eel.expose
def set_login_status(status, email=None):
    return login_manager.set_login_status(status, email)

# 获取登录状态函数
@eel.expose
def get_login_status():
    return {
        'status': 'success',
        'is_logged_in': login_manager.is_logged_in,
        'email': login_manager.current_user_email
    }

@eel.expose
@require_login
def add_sentence(source, content, author, category):
    if not login_manager.is_logged_in:
        return {'status': 'error', 'message': '请先登录'}
    
    # 获取当前登录用户
    users = load_users()
    current_user = next((u for u in users if u['email'] == login_manager.current_user_email), None)
    if not current_user:
        return {'status': 'error', 'message': '用户信息异常'}
    
    # 重定向到审核页面
    eel.redirect_to_processing()
    eel.sleep(1)  # 等待页面加载
    
    # AI审核句子内容
    try:
        eel.log_push('开始AI审核...')
        eel.status_update(3)  # 设置状态为审核中
        eel.sleep(0.1)  # 确保消息被发送
        
        review_passed = review_sentence_sync(content, author, source)
        
        if review_passed:
            eel.log_push('审核通过!')
            eel.sleep(0.1)
            eel.status_update(1)  # 设置状态为成功
            eel.sleep(0.1)
        else:
            eel.log_push('审核未通过!')
            eel.sleep(0.1)
            eel.status_update(2)  # 设置状态为打回
            eel.sleep(0.1)
            return {'status': 'error', 'message': '句子内容未通过AI审核'}
    except Exception as e:
        eel.log_push(f'审核失败: {str(e)}')
        eel.sleep(0.1)
        eel.status_update(2)  # 设置状态为打回
        eel.sleep(0.1)
        return {'status': 'error', 'message': f'AI审核失败: {str(e)}'}
    
    # 创建句子数据
    new_sentence = {
        'id': len(current_user.get('zitat', [])) + 1,
        'source': source,
        'content': content,
        'author': author,
        'category': category,
        'created_at': datetime.now().isoformat()
    }
    
    # 更新用户zitat字段
    current_user.setdefault('zitat', []).append(new_sentence)
    
    if save_users(users):
        return {'status': 'success', 'message': '句子添加成功'}
    else:
        return {'status': 'error', 'message': '数据保存失败'}

@eel.expose
@require_login
def get_all_sentences():
    if not login_manager.is_logged_in:
        return {'status': 'error', 'message': '请先登录'}
    
    users = load_users()
    current_user = next((u for u in users if u['email'] == login_manager.current_user_email), None)
    if not current_user:
        return {'status': 'error', 'message': '用户信息异常'}
    
    sentences = current_user.get('zitat', [])
    return {'status': 'success', 'data': sentences}

@eel.expose
@require_login
def delete_sentence(sentence_id):
    if not login_manager.is_logged_in:
        return {'status': 'error', 'message': '请先登录'}
    
    users = load_users()
    current_user = next((u for u in users if u['email'] == login_manager.current_user_email), None)
    if not current_user:
        return {'status': 'error', 'message': '用户信息异常'}
    
    sentences = current_user.get('zitat', [])
    # 过滤掉要删除的句子
    updated_sentences = [s for s in sentences if s.get('id') != sentence_id]
    
    if len(updated_sentences) == len(sentences):
        return {'status': 'error', 'message': '未找到要删除的句子'}
    
    # 重新编号
    for i, sentence in enumerate(updated_sentences):
        sentence['id'] = i + 1
    
    current_user['zitat'] = updated_sentences
    
    if save_users(users):
        return {'status': 'success', 'message': '句子删除成功'}
    else:
        return {'status': 'error', 'message': '句子删除失败'}

@eel.expose
@require_login
def get_sentence_by_id(sentence_id):
    if not login_manager.is_logged_in:
        return {'status': 'error', 'message': '请先登录'}
    
    users = load_users()
    current_user = next((u for u in users if u['email'] == login_manager.current_user_email), None)
    if not current_user:
        return {'status': 'error', 'message': '用户信息异常'}
    
    sentences = current_user.get('zitat', [])
    for sentence in sentences:
        if sentence.get('id') == sentence_id:
            return {'status': 'success', 'data': sentence}
    
    return {'status': 'error', 'message': '未找到句子'}

@eel.expose
@require_login
def update_sentence(sentence_id, source, content, author, category):
    if not login_manager.is_logged_in:
        return {'status': 'error', 'message': '请先登录'}
    
    if not content.strip():
        return {'status': 'error', 'message': '句子内容不能为空'}
    
    users = load_users()
    current_user = next((u for u in users if u['email'] == login_manager.current_user_email), None)
    if not current_user:
        return {'status': 'error', 'message': '用户信息异常'}
    
    sentences = current_user.get('zitat', [])
    updated = False
    
    for sentence in sentences:
        if sentence.get('id') == sentence_id:
            sentence['source'] = source
            sentence['content'] = content
            sentence['author'] = author
            sentence['category'] = category
            sentence['updated_at'] = datetime.now().isoformat()
            updated = True
            break
    
    if not updated:
        return {'status': 'error', 'message': '未找到要更新的句子'}
    
    if save_users(users):
        return {'status': 'success', 'message': '句子更新成功'}
    else:
        return {'status': 'error', 'message': '句子更新失败'}

@eel.expose
def check_password_set():
    config = read_config()
    return config['password_hash'] != ''

# 定义一个函数来启动EEL
def start_eel():
    print(f"[INFO] 一谚控制台现已运行在 127.0.0.1:1146 上。")
    eel.start('index.html', mode=None, port=1146, block=True)

# 定义一个函数来模拟持续访问EEL页面
def keep_alive():
    print(f"[INFO] 保活线程准备启动...")
    # 增加等待时间至5秒，确保EEL服务完全启动
    time.sleep(5)
    print(f"[INFO] 启动保活线程...")
    attempt = 0
    while True:
        try:
            # 延长超时时间至3秒
            response = requests.get('http://localhost:1146', timeout=3)
            print(f"[INFO] 保活请求状态码: {response.status_code} (尝试 #{attempt})")
            attempt = 0  # 重置尝试计数
        except requests.exceptions.ConnectionError as e:
            attempt += 1
            print(f"[WARN] 保活请求连接错误 (尝试 #{attempt}): {str(e)}")
        except requests.exceptions.Timeout as e:
            attempt += 1
            print(f"[WARN] 保活请求超时 (尝试 #{attempt}): {str(e)}")
        except Exception as e:
            attempt += 1
            print(f"[WARN] 保活请求失败 (尝试 #{attempt}): {str(e)}")
        # 每5秒访问一次
        time.sleep(5)

# 数据迁移：为用户数据中的句子添加id字段
def migrate_user_data():
    """迁移用户数据，为没有id的句子添加id"""
    users = load_users()
    updated = False
    
    for user in users:
        zitat = user.get('zitat', [])
        for i, sentence in enumerate(zitat):
            if 'id' not in sentence:
                sentence['id'] = i + 1
                updated = True
    
    if updated:
        save_users(users)
        print("[INFO] 用户数据迁移完成，已为句子添加id字段")

# 执行数据迁移
migrate_user_data()

# 初始化SMTP连接
print(f"[INFO] 初始化SMTP连接...")
init_smtp_connection()

# 在新线程中启动EEL
print(f"[INFO] 准备启动一谚控制台...")
"""
    eel_thread = threading.Thread(target=start_eel)
    eel_thread.daemon = True
    eel_thread.start()
"""

try:
    start_eel()
finally:
    # 确保在应用退出时关闭SMTP连接
    close_smtp_connection()

# 在新线程中启动保活功能
#keep_alive_thread = threading.Thread(target=keep_alive)
#keep_alive_thread.daemon = True
#keep_alive_thread.start()